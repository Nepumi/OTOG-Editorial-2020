# -Otog-15-Back-to-the-OTOG-Warm-Up-Contest
Solution for Contest "Back to the OTOG — Warm Up Contest"

## ข้อ 154 Problem G. Range Sum Query
### Problem
ถ้าแปลโจทย์ไม่ออก เดี๋ยวจะแปลให้ฟัง

โจทย์ประมาณว่าให้ตัวทดสอบ **t** อัน (1 <= t <= 5)
แต่ละอันจะมีตัวเลข **n** ตัวเลขและจะถาม **q** คำถาม (1 <= n,q <= 100,000)
โดยตัวเลขนั้นจะเป็นจำนวนเต็มที่ไม่ติดลบ

ส่วนคำถาม จะรับตัวเลข 2 ตัวก็คือ **i,j** (1 <= n,q <= 10,000)

หน้าที่ของคุณคือ **การที่หาผลรวมตั้งแต่ ตัวที่ i จนถึง j**

### Solution A
วิธีนี้จะเป็นตรงๆไปเลยก็คือ
1. รับตัวเลขมา n ตัว
2. รับคำถามมา(รับ i,j แหละ)
3. ในแต่ละคำถามก็วนตรงๆ(วนตั้งแต่ i ถึง j)และบวกเข้าไป
4. ตอบ

>ฟังดูง่ายๆข้อนี้ แต่หารู้ไม่ว่า วิธีนี้เป็นวิธีที่**ช้า**
>เพราะ คิดง่ายๆ สมมติเคสที่แย่ที่สุดก็คือ มี 5 เทส 100000 คำถาม และหาผลรวมตั้งแต่ 0 ถึง 10000 ทุกครั้ง
>ก็จะได้เวลาทำง่ายที่คิดง่ายๆคือ 5\*100000\*10000 = 5000000000(5 พันล้าน)ในขณะที่แบบดีที่สุดคือการคำนวณ 2 พันล้านใน 1 วินาที(แปลว่าใช้เวลา 2.5 วินาทีโดยประมาณ)


### Solution B
วิธีนี้จะใช้หลักของคณิตศาสตร์หน่อยๆ
ซึ่ง เราจะมาเรียนรู้ไปด้วยกัน

คำสั่งแรก ให้หาผลรวมของ 1+2+3+...+30
ซึ่งมันก็คือ 
![Image](https://github.com/Nepumi/-Otog-15-Back-to-the-OTOG-Warm-Up-Contest/blob/master/RES/B.PNG?raw=true) แหละ

แต่ถ้าอยากหาผลรวมของ 10+11+12+...+30 โดยที่ ![Image](https://github.com/Nepumi/-Otog-15-Back-to-the-OTOG-Warm-Up-Contest/blob/master/RES/C.PNG?raw=true) x ต้องเริ่มที่ 1 เท่านั้น จะทำยัง

สิ่งที่ทำได้ก็คือการที่นำ ![Image](https://github.com/Nepumi/-Otog-15-Back-to-the-OTOG-Warm-Up-Contest/blob/master/RES/D.PNG?raw=true)

งงละสิ ดูรูปนี้จะช่วยให้ดีขึ้น

![Image](https://github.com/Nepumi/-Otog-15-Back-to-the-OTOG-Warm-Up-Contest/blob/master/RES/A.PNG?raw=true)

หรือก็คือ ผลรวมตั้งแต่ i,j ได้โดยการ 
![Image](https://github.com/Nepumi/-Otog-15-Back-to-the-OTOG-Warm-Up-Contest/blob/master/RES/E.PNG?raw=true)

แค่นี้แหละ เราจะเปลี่ยนจาก
![Image](https://github.com/Nepumi/-Otog-15-Back-to-the-OTOG-Warm-Up-Contest/blob/master/RES/F.PNG?raw=true)
เป็น
![Image](https://github.com/Nepumi/-Otog-15-Back-to-the-OTOG-Warm-Up-Contest/blob/master/RES/G.PNG?raw=true)
ในที่นี้ขอเรียก**ผลรวมตั้งแต่ 1 ถึง i ว่า** ``` PF[i] ```

ดังนั้น หากต้องการผลรวมตั้งแต่ i ถึง j ก็คือ ``` PF[j] - PF[i-1] ```

>เว้นแต่ว่า หาก i = 1 คำตอบก็คือ ``` PF[j] ``` ทันที

เราขอเรียกวิธีนี้ว่า **Qsum** หรือทางการจะเรียกว่า **Prefix** นั้นเอง  

![Image](https://github.com/Nepumi/-Otog-15-Back-to-the-OTOG-Warm-Up-Contest/blob/master/RES/H.PNG?raw=true)

#### มาสร้าง Prefix(PF) กัน
1. กำหนดให้ PF[0] = L[0]
2. ให้ PF[i] = PF[i-1] + L[i] โดยที่ i ไล่จาก 1 ถึง n-1
>PF[i] = PF[i-1] + L[i] หมายความว่า ผลรวมที่ i = มีค่าเท่ากับผลรวมที่ i-1 + ตัวเลขปัจจุบัน

### Code Solution B

```c
#include<stdio.h>

long long PF[100002];/*Prefix ถามว่าทำไมใช้ long long
เพราะว่าตัวเลขมีทั้งหมด 100000 ตัว สูงสุดอยู่ที่ 1000000 หากเอามารวมกันทั้งหมด
ก็จะได้ 1แสนล้าน ในขณะที่ int เก็บได้สูงสุดที่ 2 พันล้าน
*/
int L[100002];//L for Lek :)

int n,q;//ขอประกาศ n,q ไว้นอก main() เพื่อที่จะสามารถเรียกใช้จากไหนก็ได้

void Make_PF(){//คำสั่งในการสร้าง PF

	PF[0] = L[0];
	for(int i=1;i<n;i++)PF[i] =(long long)(PF[i-1] + L[i]);

}

long long Sum_Range(int i,int j){//คำสั่งในการหาผลรวมตั้งแต่ i ถึง j
	if (i==0){
		return PF[j];
	}
	else{
		return PF[j]-PF[i-1];
	}
	//ไม่งงเนอะ
}

int main(){

	int t;scanf("%d",&t);
	while(t--){//วนไปจนครบ t ครั้ง
		scanf("%d %d",&n,&q);
		for(int i=0;i<n;i++)scanf("%d",&L[i]);//รับค่า n ตัว
		Make_PF();//มาสร้าง PF กันนน
		while(q--){
			int i,j;scanf("%d %d",&i,&j);
			printf("%lld\n",Sum_Range(i,j));
		}
		printf("\n");
	}

	return 0;//ใส่ไว้ไม่ทำให้แมวระเบิดหรอก

}

```


## ข้อ 176 ทำ (Just do it)
### Problem
โจทย์มีอยู่ว่าจงแปลงเลขฐาน จากฐาน A ไป ฐาน B โดย A และ B มีค่าไม่น้อยกว่า 2 และไม่มากกว่า 10 
โดยเลขนั้นไม่เกิน 2 พันล้าน

ข้อนี้ไม่ยาก แค่ต้องระลึกตอนเรียนคณิตในห้องเรียนอ่ะนะ หรือตอนเรียนพาทคณิตในค่าย 1 ก็ได้

ขอยกเนื้อหามาจากเว็ป http://www.sr.ac.th/sr_com/page_309.html มาละกัน เพราะหิวข้าวแล้วว(ขก.แหละจิงๆ)

#### การแปลงเลขฐาน a เป็นฐาน 10
ตัวอย่างการแปลงเลข 4251<ฐาน8> เป็นเลขฐาน 10

![Image](http://www.sr.ac.th/sr_com/material_009/8_10.gif)

ถ้าเป็นวิธีของการโปรแกรม ก็คือการนำตัวเลขในแต่ละหลักคูณด้วยค่าประจำหลักของฐานนั้น แล้วนำมารวมกัน

>ปุจฉา : แล้วเราจะตรวจสอบตัวเลขทีละหลักยังไง

แค่เราเปลี่ยนข้อมูลเข้า จาก **ตัวเลข** เป็น **ตัวอักษรก็ทำได้แล้ว**

>ว้าวซ่า



#### การแปลงเลขฐาน 10 เป็นฐาน b
ตัวอย่างการแปลงเลข 16<ฐาน10> เป็นเลขฐาน 2

![Image](http://www.sr.ac.th/sr_com/material_009/10_2.gif)

ถ้าเป็นวิธีของการโปรแกรม ก็คือการหาร**หาเศษ**และนำผลจากการ**ปัดเศษทิ้ง**ไปหารต่อไปเรื่อยๆจนตัวเลข**จะเป็น 0(AKA หารต่อไม่ได้)**
แล้วค่อย**นำเศษที่หาได้มากลับหลัง** เพราะถ้าดูจากรูป ด้านล่างสุด(ผลหารรอบสุดท้าย)ดันกลายเป็นด้านหน้าของคำตอบ ซึ่งเวลาเราเก็บก็เป็นเช่นกัน
*(เอาง่ายๆคือเราเก็บเหมือนเขาเลย คือเก็บจากบนมาล่าง)*


### Solution Code
 ```c
#include<stdio.h>

int main(){
	//printf("%d",'0');

	int a,b;
	scanf("%d %d",&a,&b);
	char INP[50];scanf("%s",INP);//แทนที่จะรับเป็นตัวเลข เรารับเป็นอักขระแทน
	int n = 0;

	//ส่วนที่หนึ่ง แปลงจากเลขฐาน 10 (A) เป็นเลขฐาน b ใส่ในตัวแปร B

	//หาดูว่าตัวเลขที่ใส่มีจำนวนกี่หลัก
	for(n = 0;INP[n]!='\0';n++);//ลองค่อยๆไล่ในหัวแล้วจะรู้ว่าทำไมมันตรงจำนวนหลัก

	//ตัวเลขที่ได้มามันจะกลับด้านกลับตำแหน่งที่ชี้
	//เช่น   4739
	//Index 0123
	//แปลว่าเราจะต้องทำการแปลงไล่จากหลังมาหน้ามาใส่ใน A

	int A = 0;
	int P = 1;//ค่าประจำหลักในเลขฐาน a
	for(int i=n-1;i>=0;i--){
		A += (  INP[i] - '0' ) * P;
		/*
			ปุจฉา : ทำไมต้อง INP[i] - '0'
			เพราะ INP[i] เป็นรหัสอักขระนะจ๊ะ เช่น '0' = 48
			หากเราเอามาลบกับ '0' จะได้ค่าตัวเลขที่พอดีเป๊ะ

			อักขระ	:  '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'
			รหัส  	:  48  49  50  51  52  53  54  55  56  57

			จากนั้นค่อยเอาเลขมาคูณกับค่าประจำหลักในระะบบ a
		*/

		P*= a;
	}



	//ส่วนที่สอง แปลงจากเลขฐาน 10 (A) เป็นเลขฐาน b ใส่ในตัวแปร B
	char B[1000000];//เก็บเศษในหลักต่างๆ
	int bi = 0;//ตัวชี้
	while(A>0){
		B[bi] = (A%b);
	//	B += เศษการหารด้วยตัวเลข b
		A /= b;//หารโดยการปัดเศษทิ้งเพื่อที่จะทำต่อไปเรื่อยๆ
		bi++;//เลื่อนไปยังหลักต่อไป
	}
	//แต่ยังไม่จบ เพราะตัวอักขระที่เราเก็บมานั้นมันเรียงแบบกลับด้าน
	//จึงต้องเรียงใหม่โดยการ printf ทีละตัวอักษรไปเลย
	for(int i=bi-1;i>=0;i--){//ลองนึกภาพเอาเอง
		printf("%d",B[i]);
	}

	/*
		ได้สังเกตอะไรบางอย่างไหม
		เราประกาศ char B[1000000];
		แต่กลับแสดงผลด้วย printf("%d",B[i]); WTFFF

		จริงทำได้ เพราะ char ก็เป็นตัว int ชนิดหนึ่ง แต่เก็บได้แค่ -127 ถึง 127
		ดังนั้นเลยสามารถใช้ printf("%d",B[i]);

		แล้วสรุป printf("%c"); กับ printf("%d"); ต่างกันยังไง
		ต่างกันที่ว่า %d ออกในรูปตัวเลข แต่ %c ออกในรูปตัวอักษร

		เช่น char x = 65;
		printf("%d",x); // จะออก 65
		printf("%c",x); // จะออก A

	*/

	return 0;//ใส่ return 0; ด้วยยยยยยยย

}


```
## EOF
