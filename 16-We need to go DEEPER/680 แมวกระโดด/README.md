# ข้อ 680 แมวกระโดด
ข้อนี้เป็นข้อที่ยากที่สุด และอาจจะยากสำหรับคนที่ยังไม่เคยทำพวกข้อ DFS ทั้งหลาย(เช่น มาริโอ Fruitๆๆ กรีดยางแบบมาร์เชียนไรงี้)

เพราะมันยาก เลยเอาแค่ 80 คะแนนไปก่อนละกัน

## Problem
เอาสั้นๆก็คือให้ตารางมาแบบ n x m x f (1 ≤ n,m,f ≤ 100) ก็คือตารางแบบ 3 มิติแหละ โดยแมวจะเริ่มที่บนซ้ายสุดโดยที่แมวสามารถไปได้แค่ทางด้านขวาหรือทางด้านล่าง แต่ถ้าช่องนั้นมีน้ำยามหาเทพกระโดด ซึ่งจะสามารถกระโดดขึ้นไปยังชั้นถัดไปได้
โดยเป้าหมายคือการกระโดดไปยังช่องขวาล่างสุดโดยที่มีแต้มสูงสุด **ซึ่งสามารถจบชั้นไหนก็ได้**

*เมื่อช่องนั้นมีน้ำยามหาเทพกระโดด แมวสามารถเลือกที่จะกินหรือไม่กินก็ได้(กระโดดหรือไม่ก็ได้)*

## Solution A [DFS](80 คะแนน)
วิธีนี้คือการลองไปเรื่อยๆโดยการสร้าง Function แล้วค่อยๆเรียกตัวเองเรื่อยๆ

เช่น 
```cpp 
    CAT(int now_i,int now_j,int now_l,int now_Score){
    	if(สามารถลงล่างได้)CAT(now_i+1,now_j,now_l,now_Score+Happy[now_i+1][now_j][now_l]);
	if(สามารถไปขวาได้)CAT(now_i,now_j+1,now_l,now_Score+Happy[now_i][now_j+1][now_l]);
	if(สามารถกระโดดแบบ300%ได้)CAT(now_i,now_j,now_l+1,now_Score+Happy[now_i][now_j][now_l+1]);
    }
```
ไรงี้

แต่สิ่งที่ต้องเพิ่มนิดนึงคือ
1. สามารถกระโดดแบบ300% คือการเช็คว่าแต้มในช่องนั้น**ติดลบหรือเปล่า**
2. เพิ่มการเช็คว่า มันเป็นตำแหน่งขวาล่างสุดหรือยัง ถ้าถึงแล้วก็ให้เช็คดูกับคำตอบเก่าว่าอันไหนมากว่า โดยที่**ยังไม่จบนะ เพราะช่องสุดท้ายอาจจะมีน้ำยามหาเทพกระโดดก็ได้**
3. การเพิ่มแต้มไม่ควรเรียกใน array เพราะอาจจะมี**ตัวติดลบ**ก็ได้(แต่ถ้ามีการจัดการข้อมูลดีๆก็อาจจะแยกก็ได้นะ)

### Code for Soulution A [DFS](80 คะแนน)

```c
#include<stdio.h>
#define MAX(a,b) (a>b) ?a:b
//กำหนดคำสั่ง MAX 
//เช่น MAX(3,5) คือ 5  
//MAX(6,1) คือ 6

int Score[102][102][102];//เก็บคะแนน
int Max_ANS = -1;
int n,m,f;//ขอประกาศไว้นอก main() จะได้ใช้ร่วมกันได้

/*
	ในที่นี้ขอนิยามว่า จุดบนซ้ายคือตำแหน่ง (0,0) ขวาล่างสุดคือ (n-1,m-1)
	โดยที่ตำแหน่งเป็นแบบนี้ (ขึ้นลง,ซ้ายขวา)

	แต่มันยังมีชั้นมาเกี่ยวอีก ก็จะให้ชั้นคือสมาชิกตัวแรก (ชั้น,ขึ้นลง,ซ้ายขวา)
	หวังว่าจะเข้าใจตรงกันนะ
*/

void DOBOI(int now_l,int now_i,int now_j,int now_Score){
	//ขอนิยาม now_l คือระดับชั้น ณ ปัจจุบัน
	//ขอนิยาม now_i , now_j คือตำแหน่งในชั้นที่ now_l
	//ขอนิยาม now_Score คือแต้มที่เก็บมาทั้งหมด *ก่อนถึง* ช่องตอนนี้

	int Plus_Score = 0;
	if(Score[now_l][now_i][now_j]<0){
		Plus_Score = -Score[now_l][now_i][now_j];//แปลงจากลบเป็นบวก
	}
	else{
		Plus_Score = Score[now_l][now_i][now_j];
	}

	if(now_i==n-1&&now_j==m-1){
		Max_ANS = MAX(Max_ANS,now_Score+Plus_Score);
		//เพราะ now_Score คือแต้มที่เก็บมาทั้งหมด *ก่อนถึง* ช่องตอนนี้ เราต้องบวก Plus_Score ไปอีก
	}




	if(Score[now_l][now_i][now_j]<0&&now_l+1<f){
		//ถ้าแต้มติดลบและ ยังสามารถปีนขึ้นได้
		DOBOI(now_l+1,now_i,now_j,now_Score+Plus_Score);
		//ก็ให้ปีนขึ้นไป
	}
	if(now_i+1<n){

		//ถ้ายังลงไปด้านล่างได้อยู่
		DOBOI(now_l,now_i+1,now_j,now_Score+Plus_Score);
		//ก็ให้ลงไปด้านล่าง
	}
	if(now_j+1<m){
		//ถ้ายังลงไปด้านขวาได้อยู่
		DOBOI(now_l,now_i,now_j+1,now_Score+Plus_Score);
		//ก็ให้ลงไปด้านขวา
	}

}

int main(){

	scanf("%d %d %d",&n,&m,&f);
	for(int k=0;k<f;k++){
		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){
				scanf("%d",&Score[k][i][j]);
			}
		}
	}

	DOBOI(0,0,0,0);
	//เรียก Function() โดยเริ่มจากจุด (0,0)

	printf("%d",Max_ANS);

	return 0;

}


```

## Solution B [????](100 คะแนน)
ลองคิดไปก่อนน้าาา



\*แงะ\*
