# Otog 16 We need to go DEEPER
Solution for Contest "We need to go DEEPER"

## ข้อ 294 A - Chocolate
### Problem
โจทย์ประมาณว่าขี้เมาคนนี้จะต้องหักช็อกโกแลตบาร์ขนาด **ยาว a**
ช่อง **กว้าง b ช่อง** มากที่สุดกี่ครั้งจึงจะได้ช็อกโกแลตขนาด **ยาว 1 ช่อง กว้าง 1 ช่อง จํานวน a x b
ชิ้น**

วิธีทำข้อนี้คือการ ลองสังเกตุว่ามันมีรูปแบบอะไรหรือเปล่า ซึ่งจะขอเรียกว่า Observation(หมกมุ่นแหละ)

#### Observation#1
* เวลาแบ่ง ช็อกโกแลต **1x1** เราไม่ต้องแบ่งอะไรเลย
* ในเวลาเดียวกัน ถ้าเราแบ่ง **2x1** ก็จะแบ่งได้ **1x1** 2 ชิ้น(หักไป1 ครั้ง)
* ในเวลาเดียวกัน ถ้าเราแบ่ง **2x2** ก็จะแบ่งได้ **2x1** 2 ชิ้น(หักไป1 ครั้ง)
 แล้ว **2x1** ก็จะแบ่งได้ 1 ครั้ง(หักไป 1 ครั้ง) จะได้ 2*1 + 1 = 3 ครั้ง

#### Observation#2
*(ลองจินตนาการไปพร้อมกัน)*

*(แนะนำให้ใช้ Microsoft Excel เพื่อให้นึกภาพง่ายขึ้น)*

สมมติให้แบ่งช็อคโกแลต **3x4** เราจะแบ่งแบบไหนได้บ้าง
* วิธีโง่แบบที่ 1 คือการหักเป็น **1x4** 3 อัน(หักไป 2 ครั้ง) แล้วเอา **1x4**ทั้ง 3 อันไปหักอีกจะได้ **1x1** 4 อัน(หักไป 3 ครั้ง)
ซึ่งได้ผลคือ 2 ครั้ง + 3 อัน x 3 ครั้ง = **11**
* วิธีโง่แบบที่ 2 คือการหักเป็น **1x3** 4 อัน(หักไป 3 ครั้ง) แล้วเอา **1x3**ทั้ง 4 อันไปหักอีกจะได้ **1x1** 3 อัน(หักไป 2 ครั้ง)
ซึ่งได้ผลคือ 3 ครั้ง + 4 อัน x 2 ครั้ง = **11 เหมือนกัน**
* วิธีโหด คือการหักเป็น **2x4** และ **1x4** (หักไป 1 ครั้ง) แล้วเอาอี**2x4**ไปหักเป็น **2x3** กับ **2x1** (หักไป 1 ครั้ง)
 ยังไม่จบ จากนั้นเอา **2x3** ไปหักอีกให้เหลือ **1x3** ทั้ง 2 อัน(หักไป 1 ครั้ง) 
 จากนั้นค่อยนำเศษที่เหลือไปหักต่ออีก {**1x4** หัก 3 ครั้ง} {**2x1** หัก 1 ครั้ง} {**1x3** หัก 2 ครั้ง} {**1x3** หัก 2 ครั้ง}
 ก็จะได้จำนวนหักทั้งหมด 1 + 1 + 1 + 3 + 1 + 2 + 2 = **11 เช่นกัน**
 
 สังเกตุได้ว่าแม้จะใช้วีธีโง่ หรือวิธีโหด หรือวิธีสลับฟันปลา ก็จะได้จำนวนการหัก 11 ครั้งเท่าเดิม
 
>ยังไม่เชื่ออีก

ลองแบ่งช็อคโกแลต **3x5** เราจะแบ่งแบบไหนได้บ้าง
* วิธีโง่แบบที่ 1 คือการหักเป็น **1x5** 3 อัน(หักไป 2 ครั้ง) แล้วเอา **1x5**ทั้ง 3 อันไปหักอีกจะได้ **1x1** 5 อัน(หักไป 4 ครั้ง)
ซึ่งได้ผลคือ 2 ครั้ง + 3 อัน x 4 ครั้ง = **14**
* วิธีโง่แบบที่ 2 คือการหักเป็น **1x3** 5 อัน(หักไป 4 ครั้ง) แล้วเอา **1x3**ทั้ง 5 อันไปหักอีกจะได้ **1x1** 3 อัน(หักไป 2 ครั้ง)
ซึ่งได้ผลคือ 4 ครั้ง + 5 อัน x 2 ครั้ง = **14 เหมือนกัน**
 
>ว้าวซ่า
 
 #### Observation#3
 สังเกตุจาก Observation#2 เห็นได้ว่ามันเท่าเดิมหมด ดังนั้นขอยกวิธีโง่ที่ 1 มาเป็นตัวอย่างการคำนวณละกัน
 * จาก **3x5** วิธีโง่แบบที่ 1 ทำแบบนี้
 คือการหักเป็น **1x5** 3 อัน(หักไป 3-1 ครั้ง) แล้วเอา **1x5**ทั้ง 3 อันไปหักอีกจะได้ **1x1** 5 อัน(หักไป 5-1 ครั้ง)
 ซึ่งได้ผลคือ (3-1) ครั้ง + 3 อัน x (5-1) ครั้ง = **14**
 * แค่เราเปลี่ยน 3 เป็น a และ 5 เป็น b สิ้นเรื่องแล้ว
 * ฉะนั้นก็จะได้สมการ (a-1) + a * (b-1)
 
>รออะไรละ เขียนโค้ตสิ

### Code Solution from Observation#3
```c
#include<stdio.h>

int main(){
	int a,b;scanf("%d %d",&a,&b);
  
	unsigned long long ANS = b-1;
	ANS *=a;
  /*
    ขออนุญาตสลับเป็น (b-1) * a ก่อน
    ทำไมต้อง ANS=b-1; ANS*=a; แทนที่จะ ANS = (b-1) * a;
    
    มันเป็นฮวงจุ้ย :)
  */
	ANS+=a-1;

	printf("%lld",(unsigned long long)(ANS));
  return 0;

}
```

  #### Observation#4 (จืงๆก้ไม่ observation เท่าไหร่หรอก แค่ just math)
 มีที่มาจากน้องๆที่ส่งโค้ตเข้ามา และท่านพี่ริว
 
 จากสมการ (a-1) + a(b-1) เราสามารถเปลี่ยนรูปได้
* = (a-1)+a(b-1)
* = (a-1)+ab-a
* = a-1+ab-a
* = -1+ab
* = ab-1


### Code Solution from Observation#4 และ From น้องๆ(Best Solution)
```c
#include<stdio.h>

int main(){
	int a,b;scanf("%d %d",&a,&b);
  
	unsigned long long ANS = b;
	ANS *=a;
	ANS--;

	printf("%lld",(unsigned long long)(ANS));
  return 0;

}
```


## ข้อ 356 วาระสิ้นโลก

เป็นข้อที่ให้ลองฝึกการไล่ตาราง 2 มิติ ซึ่งตอนนี้ควรจะทำได้แล้วนะครับ อิอิ

### Problem
ให้ตารางขนาด R แถว C คอลัมน์ โดยจะประกอบไปด้วยตัวอักษร 2 ตัว ก็คือ 
* 'X' แทนว่าในช่องนั้นเป็น**แผ่นดิน**
* '.' แทนว่าในช่องนั้นเป็น**น้ำ**

โดยน้ำจะท่วมแผ่นดินหากแผ่นดินนั้นมีช่องรอบ ๆ (บน-ล่าง-ซ้าย-ขวา) ที่ติดกันเป็นน้ำทะเลอย่างน้อย 3 ช่องขึ้น
ไป โดยจะพิจารณาจากแผนที่เริ่มต้นเท่านั้น

เมื่อน้ำท่วมแผ่นดินเสร็จแล้วจะเกิดภาวะโลกถล่มต่อ กล่าวคือ โลกจะเหลือเป็นรูป**สี่เหลี่ยมมุมฉากขนาดเล็ก
ที่สุด**ที่สามารถครอบคลุมแผ่นดินที่หลงเหลือทั้งหมด

งานของคุณ คือ จงเขียนโปรแกรมเพื่อหาแผ่นดินที่หลงเหลือจากวาระสิ้นโลก 

### Solution
ลองสังเกตดีๆจะเห็นว่า ตารางสูงสุดจะอยู่ที่ไม่เกิน 10 x 10 ดังนั้น ไล่โง่ๆไปเลย
โดยการเช็คว่าช่องนั้นเป็น**ดินหรือเปล่า** และ **ทั้ง บน-ล่าง-ซ้าย-ขวา ที่ติดกันเป็นน้ำทะเลอย่างน้อย 3 ช่องขึ้นหรือเปล่า** แล้วค่อยทำการ Mark ว่ามันจะจมหรือไม่

ตอนนี้จะได้ตารางประมาณแบบนี้

![ตารางที่ไล่โง่ๆแล้ว](https://github.com/Nepumi/Otog-16-We-need-to-go-DEEPER/blob/master/ImageStuff/F.png?raw=true)

> แล้วเราจะตีกรอบสีเขียวยังไงละ

ไม่ยาก แค่เราต้องหา**ขอบเขต**ของพื้นที่ๆยังรอดอยู่

> How

ทำการไล่อีกครั้งและดูว่า ตำแหน่ง**ซ้ายสุด**คือเท่าไหร่ **ขวาสุด**คือเท่าไหร่ **บทสุดกับล่างสุด**ก็เช่นกัน
* ซึ่ง **ซ้ายสุด**ก็เก็บโดยการดูว่า ระหว่าง {ค่าซ้ายสุดอันเก่า} กับ {ตำแหน่งคอลลัมน์(ซ้ายขวา)ในช่องที่**ยังมีแผ่นดินอยู่**} ว่าอันไหน**น้อยกว่า**
* **ขวาสุด**ก็เก็บโดยการดูว่า ระหว่าง {ค่าขวาสุดอันเก่า} กับ {ตำแหน่งคอลลัมน์(ซ้ายขวา)ในช่องที่**ยังมีแผ่นดินอยู่**} ว่าอันไหน**มากกว่า**
* บนกับล่างก็ลองคิดเอาเองนะ :)

### Solution Code

```c
#include<stdio.h>
#define MIN(a,b)  (a<b) ?a:b//เก็บค่าน้อย
#define MAX(a,b)  (a>b) ?a:b//เก็บค่ามาก

char MAP[12][12];//แผนที่
int LIVE[12][12];//เอาไว้เก็บว่าในช่องนั้นๆ เมื่อน้ำท่วมแล้ว จะยังมีแผนดินหรือเปล่า
//โดย 1 คือมี  0 คือบ่มี

int min_i = 20,min_j=20,max_i=-1,max_j=-1;
//ประกาศเอาไว้ตีกรอบไปก่อน
//ทำไม min ต้องเป็น 20?
//เพราะค่า min คือค่าที่น้อยที่สุด ดังนั้นเวลาเรื่มต้นก็ต้องเอาค่ามากๆไว้ก่อน ดังนั้นเปลี่ยนเป็น 35 ก็ไม่มีปัก็ไม่มีปัญหา
//เหมือนกันกับค่า max คือค่าที่มากที่สุด ดังนั้นเวลาเรื่มต้นก็ต้องเอาค่าน้อยๆไว้ก่อน

int main(){

	int n,m;scanf("%d %d",&n,&m);//รับขนาด
	for(int i=0;i<n;i++)scanf("%s",MAP[i]);//รับแผนที่ทุกๆบรรทัด

	//ไล่ดูแผนที่
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			if (MAP[i][j]=='.')LIVE[i][j] = 0;//ถ้ามันจมอยู่แล้วก็ให้จมต่อไป
			else{//แต่ถ้าไม่(มันก็คือแผ่นดินแหละ)
				int crt = 0;//นับว่ารอบๆแผ่นดินนั้นมีน้ำอยู่กี่อัน

				if(i-1>=0 && MAP[i-1][j]=='.')crt++;//ถ้า ดูอันด้านบนได้และเป็นน้ำก็บวกไปเล้ย
				if(j-1>=0 && MAP[i][j-1]=='.')crt++;//ถ้า ดูอันด้านซ้ายได้และเป็นน้ำก็บวกไปเล้ย
				if(i+1<n && MAP[i+1][j]=='.')crt++;//ถ้า ดูอันด้านล่างได้และเป็นน้ำก็บวกไปเล้ย
				if(j+1<m && MAP[i][j+1]=='.')crt++;//ถ้า ดูอันด้านขวาได้และเป็นน้ำก็บวกไปเล้ย

				
				if (crt>=3)LIVE[i][j] = 0;//ถ้าน้ำทะเลรอบๆมีจำนวนมากกว่า 3 ก็คือ จม F
				else LIVE[i][j] = 1;//ส่วนตรงข้ามก็แปลว่า พื้นที่นั้นรอด

			}

		}
	}

	//It's time to ตีกรอบ
	
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			if(LIVE[i][j]==1){
				min_i = MIN(min_i,i);
				min_j = MIN(min_j,j);
				//ไรไปและตีกรอบซะ

				max_i = MAX(max_i,i);
				max_j = MAX(max_j,j);
				//ไรไปและตีกรอบซะ
			}
		}
	}

	//คล่าวนี้ แทนที่จะไล่ทั้งหมด ก็ไล่แค่ส่วนที่ตีกรอบ
	for(int i=min_i;i<=max_i;i++){
		for(int j=min_j;j<=max_j;j++){
			if(LIVE[i][j]==1)printf("X");//ถ้ารอดก็แปลว่าเป็นแผ่นดิน
			else printf(".");//ถ้าไม่ใช่ก็แปล่ามันคือทะเล
		}
		printf("\n");//เว้นบรรทัดจ้าา
	}

	return 0;

}

```
งิ

## ข้อ 680 แมวกระโดด
ข้อนี้เป็นข้อที่ยากที่สุด และอาจจะยากสำหรับคนที่ยังไม่เคยทำพวกข้อ DFS ทั้งหลาย(เช่น มาริโอ Fruitๆๆ กรีดยางแบบมาร์เชียนไรงี้)

### Problem
เอาสั้นๆก็คือให้ตารางมาแบบ n x m x f (1 ≤ n,m,f ≤ 100) ก็คือตารางแบบ 3 มิติแหละ โดยแมวจะเริ่มที่บนซ้ายสุดโดยที่แมวสามารถไปได้แค่ทางด้านขวาหรือทางด้านล่าง แต่ถ้าช่องนั้นมีน้ำยามหาเทพกระโดด ซึ่งจะสามารถกระโดดขึ้นไปยังชั้นถัดไปได้
โดยเป้าหมายคือการกระโดดไปยังช่องขวาล่างสุดโดยที่มีแต้มสูงสุด **ซึ่งสามารถจบชั้นไหนก็ได้**

*เมื่อช่องนั้นมีน้ำยามหาเทพกระโดด แมวสามารถเลือกที่จะกินหรือไม่กินก็ได้(กระโดดหรือไม่ก็ได้)*

### Solution A [DFS](80 คะแนน)
วิธีนี้คือการลองไปเรื่อยๆโดยการสร้าง Function แล้วค่อยๆเรียกตัวเองเรื่อยๆ

เช่น 
```cpp 
    CAT(int now_i,int now_j,int now_l,int now_Score){
    	if(สามารถลงล่างได้)CAT(now_i+1,now_j,now_l,now_Score+Happy[now_i+1][now_j][now_l]);
	if(สามารถไปขวาได้)CAT(now_i,now_j+1,now_l,now_Score+Happy[now_i][now_j+1][now_l]);
	if(สามารถกระโดดแบบ300%ได้)CAT(now_i,now_j,now_l+1,now_Score+Happy[now_i][now_j][now_l+1]);
    }
```
ไรงี้

แต่สิ่งที่ต้องเพิ่มนิดนึงคือ
1. สามารถกระโดดแบบ300% คือการเช็คว่าแต้มในช่องนั้น**ติดลบหรือเปล่า**
2. เพิ่มการเช็คว่า มันเป็นตำแหน่งขวาล่างสุดหรือยัง ถ้าถึงแล้วก็ให้เช็คดูกับคำตอบเก่าว่าอันไหนมากว่า โดยที่**ยังไม่จบนะ เพราะช่องสุดท้ายอาจจะมีน้ำยามหาเทพกระโดดก็ได้**
3. การเพิ่มแต้มไม่ควรเรียกใน array เพราะอาจจะมี**ตัวติดลบ**ก็ได้(แต่ถ้ามีการจัดการข้อมูลดีๆก็อาจจะแยกก็ได้นะ)

### Code for Soulution A [DFS](80 คะแนน)

```c
#include<stdio.h>
#define MAX(a,b) (a>b) ?a:b
//กำหนดคำสั่ง MAX 
//เช่น MAX(3,5) คือ 5  
//MAX(6,1) คือ 6

int Score[102][102][102];//เก็บคะแนน
int Max_ANS = -1;
int n,m,f;//ขอประกาศไว้นอก main() จะได้ใช้ร่วมกันได้

/*
	ในที่นี้ขอนิยามว่า จุดบนซ้ายคือตำแหน่ง (0,0) ขวาล่างสุดคือ (n-1,m-1)
	โดยที่ตำแหน่งเป็นแบบนี้ (ขึ้นลง,ซ้ายขวา)

	แต่มันยังมีชั้นมาเกี่ยวอีก ก็จะให้ชั้นคือสมาชิกตัวแรก (ชั้น,ขึ้นลง,ซ้ายขวา)
	หวังว่าจะเข้าใจตรงกันนะ
*/

void DOBOI(int now_l,int now_i,int now_j,int now_Score){
	//ขอนิยาม now_l คือระดับชั้น ณ ปัจจุบัน
	//ขอนิยาม now_i , now_j คือตำแหน่งในชั้นที่ now_l
	//ขอนิยาม now_Score คือแต้มที่เก็บมาทั้งหมด *ก่อนถึง* ช่องตอนนี้

	int Plus_Score = 0;
	if(Score[now_l][now_i][now_j]<0){
		Plus_Score = -Score[now_l][now_i][now_j];//แปลงจากลบเป็นบวก
	}
	else{
		Plus_Score = Score[now_l][now_i][now_j];
	}

	if(now_i==n-1&&now_j==m-1){
		Max_ANS = MAX(Max_ANS,now_Score+Plus_Score);
		//เพราะ now_Score คือแต้มที่เก็บมาทั้งหมด *ก่อนถึง* ช่องตอนนี้ เราต้องบวก Plus_Score ไปอีก
	}




	if(Score[now_l][now_i][now_j]<0&&now_l+1<f){
		//ถ้าแต้มติดลบและ ยังสามารถปีนขึ้นได้
		DOBOI(now_l+1,now_i,now_j,now_Score+Plus_Score);
		//ก็ให้ปีนขึ้นไป
	}
	if(now_i+1<n){

		//ถ้ายังลงไปด้านล่างได้อยู่
		DOBOI(now_l,now_i+1,now_j,now_Score+Plus_Score);
		//ก็ให้ลงไปด้านล่าง
	}
	if(now_j+1<m){
		//ถ้ายังลงไปด้านขวาได้อยู่
		DOBOI(now_l,now_i,now_j+1,now_Score+Plus_Score);
		//ก็ให้ลงไปด้านขวา
	}

}

int main(){

	scanf("%d %d %d",&n,&m,&f);
	for(int k=0;k<f;k++){
		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){
				scanf("%d",&Score[k][i][j]);
			}
		}
	}

	DOBOI(0,0,0,0);
	//เรียก Function() โดยเริ่มจากจุด (0,0)

	printf("%d",Max_ANS);

	return 0;

}


```

### Solution B [DP](100 คะแนน)
/!\\ หากใครไม่เข้าใจให้ข้ามไปก่อน เพราะมันเป็นเนื้อหาในอนาคต :) /!\\

DP หรือ Dynamic Programming หรือ การเขียนโปรแกรมแบบไดนามิก(แปลจากgoogle) หรือ กำหนดการพลวัต คือกระบวนการหาค่าเหมาะที่สุด โดยแก้ไขปัญหาที่ซับซ้อนโดยการแบ่งปัญหาให้เป็นปัญหาย่อยที่สามารถแก้ได้ง่ายกว่าในลักษณะของ**การเรียกซ้ำ**(ก็อปมาจากวิกิงะ)

ดังนั้นสิ่งที่เป็น**อาหาร**ในการเลี้ยงดู **Dynamic Programming** ก็คือ **สมการ Recurrent**
> มันคืออะไรอี๊ก

คือสมการที่สามารถหาคำตอบ**ที่ดีที่สุด**โดยส่วนมากจะเป็น**การเรียกซ้ำ**

*\*อันนี้เป็นเพียงแค่น้ำจิ้มของ Dynamic Programming :)\**

ในที่นี้ขอกำหนดสมการ Recurrent ข้อนี้คือ...

![Sammakarn](https://github.com/Nepumi/Otog-16-We-need-to-go-DEEPER/blob/master/ImageStuff/A.PNG?raw=true)

- ให้ ![Dp](https://github.com/Nepumi/Otog-16-We-need-to-go-DEEPER/blob/master/ImageStuff/B.PNG?raw=true) คือคำตอบที่ดีที่สุดใน (i,j)  ในชั้นที่ l
- ให้ ![P](https://github.com/Nepumi/Otog-16-We-need-to-go-DEEPER/blob/master/ImageStuff/C.PNG?raw=true) คือ แต้มในช่องที่ (i,j) ชั้นที่ l
- ให้ ![V](https://github.com/Nepumi/Otog-16-We-need-to-go-DEEPER/blob/master/ImageStuff/D.PNG?raw=true) หมายความว่า แมวไปในช่อง(i,j) ชั้นที่ l ได้หรือไม่
- ให้ ![ย](https://github.com/Nepumi/Otog-16-We-need-to-go-DEEPER/blob/master/ImageStuff/E.PNG?raw=true) หมายความว่า ในช่อง (i,j) ชั้นที่ l มียาหรือไม่


#### แบบ Top-Down 
ขออนุญาตข้ามการอธิบายแบบ Top-Down เพราะมันไม่แน่ใจว่าจะเรียก Top-Down ได้ไหม
อีกทั้ง แบบต่อไปเป็นวิธีที่ดีกว่า

*จริงๆ โซลก็นำโซลเก่ามาประยุกต์ที่ว่า ให้ Function นั้น return เป็นตัวเลข แล้วค่อยจำเก็บ DP
ถ้ามีเราเคยทำแล้ว จะได้ตอบคำถามเลยโดยที่ไม่ต้องทำซ้ำ
จึงเป็นสาเหตุว่าทำไมมันเร็วกว่ามาก*

```c
#include<stdio.h>
#define MAX(a,b) (a>b) ?a:b
#define ABS(a) (a<0) ? a*(-1) : a // แค่เป็นคำสั่งเปลี่ยนจากลบเป็นบวก
//กำหนดคำสั่ง MAX เช่น MAX(3,5) คือ 5  MAX(6,1) คือ 6

int Score[102][102][102];//เก็บคะแนน
int DP[102][102][102];//Dynamic
char VIS[102][102][102];//ดูว่าในช่องนี้ แมวสามารถมาได้ไหม
//ทำไมใช้ Char เพราะเราจะเก็บแค่มาไม่มา(0 หรือ 1) ดังนั้นใช้ Char ก็พอแล้วว
//ทำไมไม่ใช้ bool .......ขี้เกียจ include งะ

int n,m,f;//ขอประกาศไว้นอก main() จะได้ใช้ร่วมกันได้

/*
	ในที่นี้ขอนิยามว่า จุดบนซ้ายคือตำแหน่ง (0,0) ขวาล่างสุดคือ (n-1,m-1)
	โดยที่ตำแหน่งเป็นแบบนี้ (ขึ้นลง,ซ้ายขวา)

	แต่มันยังมีชั้นมาเกี่ยวอีก ก็จะให้ชั้นคือสมาชิกตัวแรก (ชั้น,ขึ้นลง,ซ้ายขวา)
	หวังว่าจะเข้าใจตรงกันนะ
*/

int DOBOI(int now_l,int now_i,int now_j){
	//ขอนิยามฟังก์ชั่นนี้คือ คะแนนที่ดีที่สุดโดยมีจุดเริ่มต้นจาก (now_i,now_j) ในชั้นที่ now_l
	//ขอนิยาม now_l คือระดับชั้น ณ ปัจจุบัน
	//ขอนิยาม now_i , now_j คือตำแหน่งในชั้นที่ now_l
	//printf("Doing <%d>[%d,%d]...\n",now_l,now_i,now_j);
	//if(DP[now_l][now_i][now_j])printf("return <%d>(%d,%d) = %d!\n",now_l,now_i,now_j,DP[now_l][now_i][now_j]);
	if(DP[now_l][now_i][now_j])return DP[now_l][now_i][now_j];
	//ถ้าค่านี้เคยหาไว้แล้ว (ไม่เป็น 0) ให้ return ไปเลย ไม่ต้องไปหาอีก
	int Max_ANS = 0;

	int Plus_Score = ABS(Score[now_l][now_i][now_j]);//เก็บคะแนนที่กำลังจะบวกเพิ่ม ให้เป็นค่าบวกเสมอ


	if(now_i-1>=0){
		//ถ้ายังลงไปด้านล่างได้อยู่ ก็ลองส่งกำลังเสริมไปหาคำตอบก่อน
		int Go_Score = DOBOI(now_l,now_i-1,now_j)+Plus_Score;
		if(VIS[now_l][now_i-1][now_j]){
			Max_ANS = MAX(Max_ANS,Go_Score);
			//ลองเช็คว่าระหว่าง {อันเก่า} กับ {คำตอบที่ดีที่สุดในถัดไป + คะแนนตอนนี้} อันไหนสูงกว่า
			VIS[now_l][now_i][now_j] = 1;
		}

	}
	if(now_j-1>=0){
		//ถ้ายังไปด้านซ้ายได้อยู่ ก็ลองส่งกำลังเสริมไปหาคำตอบก่อน
		int Go_Score = DOBOI(now_l,now_i,now_j-1)+Plus_Score;
		if(VIS[now_l][now_i][now_j-1]){
			Max_ANS = MAX(Max_ANS,Go_Score);
			//ลองเช็คว่าระหว่าง {อันเก่า} กับ {คำตอบที่ดีที่สุดในถัดไป + คะแนนตอนนี้} อันไหนสูงกว่า
			VIS[now_l][now_i][now_j] = 1;
		}

	}
	if(now_l-1>=0&&Score[now_l-1][now_i][now_j] < 0){
		//ถ้ายังลงไปชั้นที่แล้ว และชั้นที่แล้วมีน้ำยามหาเทพกระโดด ก็ลองส่งกำลังเสริมไปหาคำตอบก่อน
		int Go_Score = DOBOI(now_l-1,now_i,now_j)+Plus_Score;
		if(VIS[now_l-1][now_i][now_j]){
			Max_ANS = MAX(Max_ANS,Go_Score);
			//ลองเช็คว่าระหว่าง {อันเก่า} กับ {คำตอบที่ดีที่สุดในถัดไป + คะแนนตอนนี้} อันไหนสูงกว่า
			VIS[now_l][now_i][now_j] = 1;
		}

	}

	//printf("return <%d>(%d,%d) = %d!\n",now_l,now_i,now_j,Max_ANS);
	//ปล่อยค่า Max_ANS รวมทั้งเก็บค่า Max_ANS ไว้ใน DP[now_l][now_i][now_j];
	return DP[now_l][now_i][now_j] = Max_ANS;

}

int MS = 0;

int main(){


	scanf("%d %d %d",&n,&m,&f);
	for(int k=0;k<f;k++){
		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){
				scanf("%d",&Score[k][i][j]);
			}
		}
	}
	VIS[0][0][0] = 1;//กำหนดให้แมวสามารถไปยัง (0,0) ชั้น 0 ได้
	DP[0][0][0] = ABS(Score[0][0][0]);//และให้ DP[0,0,0] เป็นคะแนนช่อง[0,0,0] ไปเลย

	for(int k=0;k<f;k++){
		MS = MAX(MS,DOBOI(k,n-1,m-1));
		//เพราะมันสามารถจบได้หลายชั้น ก็ต้องไล่ไปทีละชั้นและเอาชั้นที่ดีที่สุด
	}


	printf("%d",MS);

	return 0;

}


```
จริงๆแค่นี้ก็ได้ 90 แล้ว แต่มา Solution ที่ดีกว่า *และอาจเข้าใจง่ายกว่ามั้ง*

#### แบบ Bottom-Up
ก็คือนำคำตอบอันเล็กๆมาสร้าง คำตอบที่ใหญ่กว่านี่เอง
ถ้าเป็นในชั้นแรก ไม่มีปัญหาเพราะ **เราสามารถมาได้ทุกตำแหน่งในชั้นแรกอยู่แล้ว**
แต่ในชั้นถัดๆไปอาจจะไม่ได้ เพราะ น้ำยามหาเทพกระโดดไม่ได้มีทุกช่องอีก ดังนั้น **อาจมีบางช่องที่แมวไม่สามารถมาได้**

ดังนั้นการจะนำคำตอบอันเล็กๆมาสร้างคำตอบอันใหญ่ๆได้นั้น จะต้องเช็คก่อนว่า **แมวสามารถมาตรงนี้ได้หรือไม่**
ซึ่งเราสามารถทำได้โดยการเก็บ **Visit ว่าไอ้แมวมายัง** และในระหว่างการสร้างคำตอบใหม่ **ให้เช็คก่อนว่าแมวสามารถมาตรงนี้ได้หรือไม่** จากนั้นค่อยบอก ให้ **Visit ในตำแหน่งปัจจุบันเก็บว่า"มาแล้ว"**

> งงมั้ย งงละสิ

### Code for Soulution B [DP(Bottom-Up)](100 คะแนน)

```c
#include<stdio.h>
#define MAX(a,b) (a>b) ?a:b //เหมือนเดิม ดูว่าอันไหนมีค่ามากกว่ากัน แล้วค่อยปล่อยค่าที่มากกว่า
#define ABS(a) (a<0) ? a*(-1) : a // แค่เป็นคำสั่งเปลี่ยนจากลบเป็นบวก

int Score[102][102][102];//เก็บแต้มในช่องแต่ละช่อง
char Visited[102][102][102];//ดูว่าในช่องนี้ แมวสามารถมาได้ไหม
//ทำไมใช้ Char เพราะเราจะเก็บแค่มาไม่มา(0 หรือ 1) ดังนั้นใช้ Char ก็พอแล้วว
//ทำไมไม่ใช้ bool .......ขี้เกียจ include งะ
int DP[102][102][102];//DP
int n,m,f;

int MS;//ประกาศไว้รอก่อน ซึ่ง MS ย่อมาจาก (M)าก(Sุ)ด(มากสุด)

int main(){


	scanf("%d %d %d",&n,&m,&f);
	for(int k=0;k<f;k++)for(int i=0;i<n;i++)for(int j=0;j<m;j++)scanf("%d",&Score[k][i][j]);
	//ขออนุญาตเขียนเป็นบรรทัดเดียว

	Visited[0][0][0] = 1;//กำหนดให้ว่าแมวสามารถไปที่ช่อง (0,0) ชั้น 0 ได้ (จุดเริ่มต้นแหละ)

	for(int k=0;k<f;k++){//วนไปทุกๆชั้น
		for(int i=0;i<n;i++){
			for(int j=0;j<m;j++){//วนไปทุกๆตำแหน่ง

				int NScore = ABS(Score[k][i][j]);
				DP[k][i][j] = NScore;
				//NScore คะแนนที่จะได้ในช่องนี้ (เป็น +)

				/*
				วิธีการนี้ จะทำการเทียบอันเก่าและบวกค่าใหม่เพื่อให้เป็นคำตอบที่ดีที่สุด
				โดยการเทียบอันเก่าเราทำได้ดังนี้
				*ลองคิดไปด้วยนะว่าตอนนี้อยู่ประมาณกลางๆขิงตาราง*

					    ถ้ามีอันบนอยู่   และอันบนเป็นที่ๆแมวไปได้ ก็ลองเทียบว่าอันไหนมากกว่า
					หรือ ถ้ามีทางด้านซ้าย และทางด้านซ้ายเป็นที่ๆแมวไปได้ ก็ลองเทียบว่าอันไหนมากกว่า
					หรือ ถ้ามีระดับชั้นที่ต่ำกว่า และมีน้ำยามหาเทพกระโดด และระดับชั้นที่ต่ำกว่าเป็นที่ๆแมวไปได้ ก็ลองเทียบว่าอันไหนมากกว่า

					แล้วเราค่อยเอาค่าที่มากที่สุดมาใส่ในคำตอบ(ใส่ในช่องปัจจุบัน)
				*/


				if(i-1 >= 0 && Visited[k][i-1][j]){
					// ถ้ามีอันบนอยู่   และอันบนเป็นที่ๆแมวไปได้
					Visited[k][i][j] = 1;
					DP[k][i][j] = MAX(DP[k][i][j],DP[k][i-1][j]+NScore);
				}
				if(j-1 >= 0 && Visited[k][i][j-1]){
					// ถ้ามีทางด้านซ้าย และทางด้านซ้ายเป็นที่ๆแมวไปได้ ก็ลองเทียบว่าอันไหนมากกว่า
					Visited[k][i][j] = 1;
					DP[k][i][j] = MAX(DP[k][i][j],DP[k][i][j-1]+NScore);
				}
				if(k-1 >= 0&&Score[k-1][i][j]<0 && Visited[k-1][i][j]){
					// ถ้ามีระดับชั้นที่ต่ำกว่า และมีน้ำยามหาเทพกระโดด และระดับชั้นที่ต่ำกว่าเป็นที่ๆแมวไปได้ ก็ลองเทียบว่าอันไหนมากกว่า
					Visited[k][i][j] = 1;
					DP[k][i][j] = MAX(DP[k][i][j],DP[k-1][i][j]+NScore);
				}

			}
		}
		//จบตารางในชั้นนั้นๆแล้ว
		//เราค่อยมาดูว่า ตำแหน่งสุดท้ายในชั้นปัจจุบัน มีค่ามากกว่ากับคำตอบหรือเปล่า
		MS = MAX(DP[k][n-1][m-1],MS);
	}
	//ปริ้นคำตอบที่ดีที่สุด
	printf("%d",MS);
	return 0;

}

```

\*แงะ\*

## EOF
