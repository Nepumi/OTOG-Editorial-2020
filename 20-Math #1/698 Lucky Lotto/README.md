# ข้อ 689 Lucky Lotto
## Problem
ประมาณว่ามีลำดับ 1 2 2 2 3 3 3 3 3 5 5 5 5 5 5 5 ... ที่พัคพูมได้ถูต้นกะเพราเพื่อขอหวยอยู่ ซึ่งโจทย์จะถามว่าไอ้ลำดับนั้นแหละ พจน์ที่ n(ตัวเลขที่ n)ว่า มันคือตัวเลขอะไร?? 

## Solution A Simulate(30 point)

> จาก นานี๊ ผมเห็นลำดับเป็น 1 2 2 2 3 3 3 3 3 ซึ่ง  เลขถัดไปจะเป็น ลำดับฟีโบ  แล้วจะที่เลขนั้น คือ เลขปัจจุบัน + เลขก่อนหน้า 

ใช่ครับมันคือ**ลำดับฟิโบนักชี**(ก็คือ f(n) = f(n-1)+f(n-2) เมื่อ f(1) = 1,f(2) = 2) *ถึงตอนนี้คงคิดว่าน่าจะรู้กันหมดแล้วว่าลำดับฟีโบนักชีคืออะไร* ถามว่าทำไมมัน**ไม่ใช่จำนวนเฉพาะ** ก็เพราะว่า **1 ไม่ใช่ PRIME**

ถ้าเราสังเกตดีๆ เราจะเห็นว่าตัวเลขมันซ้ำกัน **1 ตัว 3 ตัว 5 ตัว 7 ตัว** ไปเรื่อยๆ นั้นคือตัวเลขจะ**ซ้ำ**เป็นจำนวน**เลขคี่** 

อ่าวแค่นี้ก็ง่ายเลยสิ ก็ไล่โง่ๆไปจนถึงพจน์ที่ n ก็สิ้นเรื่อง และตอนไล่ก็หา ฟีโบนักชี ไปด้วย

## Solution Code A(30 point)
```cpp
#include<stdio.h>

int main(){

	int t;scanf("%d",&t);//รับ t คำถาม

	while(t--){//วนไปจนกว่าจะหมดคำถาม
		int n;scanf("%d",&n);//รับ n เข้าปาาาาย
		int TEPLEK = 1;//เอาไว้นับเฉยๆว่าเป็นเลขที่ตัวที่เท่าไหร่
		int CRT = 1;//ไว้นับว่าไอ้ลำดับนี้จบที่เท่าไหร่
 
		//เจ้าสองตัวนี้มันคือตัวคำนวณฟิโบแบบเร็วขึ้นนิดนึง
		int pre = 1;
		int now = 1;

		while(n>CRT){//วนจนกว่า CRT จะมีค่ามากกว่าหรือเท่ากับ n(หรือก็คือวนจนกว่าจุดจบมันจะเลย n)
			//คำนวณเลขคี่บลาๆๆๆ
			TEPLEK++;
			CRT += TEPLEK*2-1;
      
			//คำนวณฟิโบ
			int tod = pre;
			pre = now;
			now = now + tod;
		}

		printf("%d\n",now);//ได้แล้วตอบไปเลย
	}
	return 0;

}
```
> ทำไมได้แค่ 30 คะแนนอะ ผิดตรงไหน! มันรับไม๊ด๊าาาาาาาาาาาาาาาาาาาาาาย!!!


## Solution B Precalculated and Obtimization(100 point)

**เรามาดูกันว่าเรามีปัญหาอะไรบ้าง**

### Problem A เราจะมีวิธีดูว่าในพจน์ที่ n มันคือตัวเลข ฟิโบ ตัวที่เท่าไหร่

ถ้าเราลองค่อยๆคิดจะเห็นว่าเลขฟิโบมันจะซ้ำเป็น**1ตัว 3ตัว 5ตัว...(เลขคี่แหละ)** ถ้าเรารู้ว่า**ไอ้ n มันอยู่ในตัวเลขที่จบกี่ตัว**เราก็สิ้นเรื่อง

ซึ่งการที่จะดูได้นั้น n จะต้องน้อยกว่า **1 + 3 + 5 + ... + (2x-1)** โดย **x ต้องมากที่สุด**

เช่น 

n = 2 แปลว่ามัน**จบที่ 3 ตัว**(ตัวเลข**ฟิโบที่ 2**) (2 < 1+3)

n = 6 แปลว่ามัน**จบที่ 5 ตัว**(ตัวเลข**ฟิโบที่ 3**) (6 < 1+3+5)

แต่เราจะทำไงให้**เร็วๆ**?? 

มี 2 วิธี
#### วิธีแรก Observation
ลองให้ x = 1 เราจะได้ *1* = *1*

ลองให้ x = 2 เราจะได้ *4* = *1+3*

ลองให้ x = 3 เราจะได้ *9* = *1+3+5*

ลองให้ x = 4 เราจะได้ *16* = *1+3+5+7*

ลองให้ x = 5 เราจะได้ *25* = *1+3+5+7+9*

ผลรวมเมื่อ x = ?? ก็จะได้ *??^2*

> เห็นอะไรใช่ไหม

#### วิธีสอง อนุกรมเลขคณิตและลำดับเลขคณิต

จะเห็นว่า 1 3 5 7 9.. มันเป็น**ลำดับเลขคณิต** *(ลำดับเลขคณิตคือลำดับที่จะมีผลต่างเท่ากัน(ห่างเท่ากันแหละ))*
ซึ่งเราสามารถใช้สูตร **อนุกรมเลขคณิต(ก็คือผลรวมของลำดับเลขคณิต)** ได้ Sn = ( n / 2 )( a1 + an )

ซึ่งเราจะหา 1 + 3 + 5 + ... + (2x-1) นั้นคือ Sn = ( x / 2 )( 1 + (2x-1) ) = x^2

จากทั้ง 2 วิธีก็จะได้เป็น **x^2** นั้นหมายความว่า

ตัวเลขฟิโบที่ **1** จะจบที่ลำดับที่ 1^2 = **1**

ตัวเลขฟิโบที่ **2** จะจบที่ลำดับที่ 2^2 = **4**

ตัวเลขฟิโบที่ **3** จะจบที่ลำดับที่ 3^2 = **9**

อะ! ลอง**สลับกันจะได้ง่ายขึ้น**

ลำดับที่ **1** คือ ตัวเลขฟิโบที่ ?^2 = **1** ? = 1 (ก็คือ Fiboตัวที่ **1**)

ลำดับที่ **4** คือ ตัวเลขฟิโบที่ ?^2 = **4** ? = 2 (ก็คือ Fiboตัวที่ **2**)

ลำดับที่ **9** คือ ตัวเลขฟิโบที่ ?^2 = **9** ? = 3 (ก็คือ Fiboตัวที่ **3**)

แต่

ลำดับที่ **8** หละ มันก็ คือ ตัวเลขฟิโบที่ ?^2 = **9** ? = 2.828 (ก็คือ Fiboตัวที่ **3 ซึ่งเราก็ปัดเศษขึ้น**)

นั้นหมายความว่า **ลำดับที่(หรือพจน์ที่) n** มันก็คือ**ฟิโบตัวที่ รากที่ 2 ของ n ที่ถูกปัดเศษขึ้นแล้ว**

### Problem B แล้วทำไมมันยังบึ้มอะ
จากการแก้ของ **Problem A** ลำดับที่(หรือพจน์ที่) n มันก็คือฟิโบตัวที่ รากที่ 2 ของ n

ซึ่งข้อนั้น n สูงสุด จะอยู่ที่ **n = 1000000** มันก็คือฟิโบตัวที่ **1000** ซึ่งคือ 
70330367711422815821835254877183549770181269836358732742604905087154537118196933579742249494562611733487750449241765991088186363265450223647106012053374121273867339111198139373125598767690091902245245323403501 

> พี่ไม่รู้ว่าใครเขียน "เกร็ดความรู้ :" อ่ะ :D

ว้าวซ่า มันเยอะมากๆเลย ถ้าเราใช้ unsigned long long ซึ่งรับได้สูงสุดประมาณ 10^18 ก็ยังอ่อนหัดอยู่ดี ลืม double ไปเลยเพราะเราอยากได้ค่าที่เป๊ะๆ ซึ่ง double มันจะให้เป็นค่า**ประมาณ**ออกมา แล้วจะทำไงละ ม่าาาาาาย

มีอีกวิธีอยู่ ซึ่งก็ใช้หลักที่ชีวิตประจำวันเราใช้นี้แหละก็คือ **BigNum** หรือก็คือ **ตัวเลขยักษ์**...ห้ะ ใช่ แต่ตัวเลขนี้ไม่ใช่ int ไม่ใช่ float แต่เป็น**ตัวอักขระหลายๆตัวด้วยกัน(string)** ที่เหมือนกับเราเขียนบนกระดาษ **ซึ่งวิธีนี้จะทำให้เราใช้ตัวเลขกี่หลักก็ได้ตราบใดที่ยังไม่ระเบิด** แต่ก็ต้องแรกกับการเขียนยากเหมือนกัน ซึ่งในที่นี้ขอกำหนดให้จำนวนหลักเป็น 300 หลักละกัน

> เราจะบวกยังไงอะ

ปัญหาตอนนี้คือถ้า**บวก string 2 อัน**มันก็จะกลายเป็น **ต่อกัน** ไปโดยปริยาย ฉะนั้นเราจะต้องเขียน**การบวกแมวๆเอง** ซึ่งไอ้บวกแมวๆนั้นแหละ เราจะต้องใช้วิธีตอนประถมมาช่วย

คูรรครูครรัันราับ(คุณครูครับ) 357 + 489 ด้าาาาายเทท่่่าาา่าา่า่าไหรรร่ร่ร่ร่รรค้าาาาาาาาพ(ได้เท่าไหร่ครับ)

เราก็เอาหลักหน่วยมาบวกกัน(7+9 ได้ 6 ทด 1) แล้วก็หลักสิบ(5+8+1 ได้ 4 ทด 1) และจบที่หลักร้อย(3+4+1 ได้ 8) ก็จะได้ 846

แค่นี้แหละ เราก็ให้**หลักหน่วย**เป็นอักขระ**ช่องที่ 0**  **หลักสิบ**เป็น**ช่องที่ 1** และไปเรื่อยๆ จากนั้นก็**วนแต่ละหลัก**แล้วก็ทำการ**บวกกัน เก็บผลลัพธ์และตัวทดและทำซ้ำจนกว่าจะเสร็จ**

### Problem C คิดว่ามันดียัง

ถ้าเรายัง**วนไล่หาฟิโบทุกรอบ** **มั น จ ะ ท ำ ใ ห้ เ สี ย เ ว ล า** และ **ส่งอีกกี่วันก็ไม่ผ่านสักทีหรอก**

เราลองคิดง่ายๆนะว่า ถ้ามัน**ถาม 10000 ครั้ง** แต่ละครั้งก็ใส่ n = 1000000 ก็คือลำดับฟิโบ**ตัวที่ 1000** ซึ่งเวลาเราหาเราก็ต้อง**บวกเลข 300 หลัก** เราก็จะได้เวลาแมวๆคือ *O(10000\*1000\*300)* = O(3,000,000,000) (โดยปกติ 2พันล้าน(หรือร้อยล้าน)ก็เกิน 1 วิแล้ว) ซึ่งมันไม่ทันแน่ๆ

เพราะปัญหานี้เราจึงใช้วิธีอีกเครื่องก็คือ **Precalculated(คำนวณไว้ก่อน)** ซึ่งเริ่มโปรแกรมมาก็หาฟิโบตัวที่ 1 ถึง 1000 ไปเลย

*ในที่นี้ขออนุญาตใช้ sqrt และ ceil ในการคำนวณ*

> อ่าว แต่ sqrt มันให้ค่าประมาณออกมาไม่ใช่ออ ห้ะ!!!!!

กรณีใช้นี้ใช้ได้ ถามว่าทำไม ลองดูบรรทัดสุดท้ายละกัน



## Solution Code B(100 point) ดัดแปลงจากของผู้แทนคะแนนร้อยนึง

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mxfib = 1100, mxn = 1e6, mxs = 300;
/*กำหนดค่าคงตัว ซึ่งมีดังนี้
    mxfib = Max Fibo
    mxn = Max n
    mxs = Max อะไรสักอย่าง แต่ก็คือจำนวนหลักของตัวเลขอันสูงสุดแหละ
*/
string zero = string(mxs, '0');//เรากำหนดให้เลข 0 คือ "0000000000000000000000000000000...000000"

string add(string a, string b){//การบวกตัวเลขแมวๆ
    string res=zero;//ให้ผลเป็น 0 ไปก่อน
    int carry = 0;//ตัวทด
    for(int i = 0; i != mxs; ++i){//วนไปให้ครบทุกหลัก TIP ++i เร็วกว่า i++
        int u = a[i]-'0', v = b[i]-'0';//เปลี่ยนจากตัวอีกษรเป็นตัวเลขของที่สองตัว
        int sum = u + v + carry;//บวกเลขในหลักนั้นๆ
        int r = sum%10;//ผลลัพธ์
        carry = sum/10;//ตัวทด
        res[i] = r+'0';//ใส่ผลลัพธ์ในหลักนั้นๆ
    }
    return res;//และค่อยให้ปล่อยผลลัพธ์ออกมา
}
string fibo[mxfib];//เก็บตัวเลขฟิโบทั้งหลาย

int main(){


    for(int i=1;i<mxfib;i++){
    	fibo[i] = zero;//กำหนดให้ทุก fibo เป็น 0
    }

    //ในที่นีัขอกำหนดให้หลักหน่วยคือตัวอักษรช่องที่ 0

    fibo[1][0] = '1';//กำหนด fibo ตัวที่ 1 คือ 1
    fibo[2][0] = '2';//กำหนด fibo ตัวที่ 2 คือ 2


    string a = fibo[1], b = fibo[2];//จากนั้นทำการหาตัวอื่นๆโดยการที่ b คืออันก่อนหน้า และ a คือการก่อนหน๊า
    for(int i = 3; i != mxfib; ++i){
        fibo[i] = add(a, b);//หาฟิโบปัจจุบัน
        a = b;//ให้ a เป็นอันเก่าสุด
        b = fibo[i];//ให้ b เป็นฟิโบปัจจุบัน
    }
    int t;//รับจำนวนคำถาม
    cin >> t;
    for(int i = 0, n; i != t; ++i){//วนครบทุกคำถาม
        cin >> n;//รับ n มา
        string res = fibo[int(ceil(sqrt(n)))];

		/*ประเด็นมันอยู่ตรงนี้
		    เรากำหนดให้หลักหน่วยอยู่ในช่องที่ 0
		    ให้หลักสิบอยู่ในช่องที่ 1
		    แต่ความเป็นจริง เราเขียนตัวเลขหลักสูงสุดก่อนๆ และค่อยย้อนกลับมาเป็นหลักหน่วย
		    เช่น 1235 เราเขียน 1(หลักพัน) แล้ว 2(หลักร้อย) 3(หลักสิบ) และจบที่5(หลักหน่วย)

		    งั้นเราก็กลับด้านไปเล้ยไม่ได้หรอ

		    ก็ได้แต่ปัญหาคือ 123005 ในโปรแกรมมันเก็บเป็น 5003210000000000000000000000000.... ตามคำนิยามของเรา
		    ดังนั้นถ้าเรากลับด้านมันก็จะเป็น 00000000...0000000123005 เพราะงั้น เราก็ไล่วนหาว่าหลักไหนเป็นหลักแรก
		    ........................................^.....
		*/

	    reverse(res.begin(), res.end());//ทำการกลับด้านมัน และหาหลักแรก
		bool Founded = false;
		for(int i=0;i<mxs;i++){
			if(!Founded){//ถ้ายังไม่เจอ
				Founded = (res[i] != '0');//ก็เช็คว่าไม่ใช่เลข 0 ไหม
				if(Founded)cout<<res[i];//ถ้าเจอแล้วก็บอก
			}
			else{
				cout<<res[i];//แล้วก็บอกๆๆๆ
			}
		}
		cout<<'\n';//เว้นบรรทัด
    }
    return 0;//ว้าวซ่า
}

```

### ทำไมรอบนี้เราใช้ sqrt ได้(ถ้าไม่สงสัยก็ข้ามผ่านได้ เพราะข้อมูลค่อนข้างลึกใช้ได้)

อย่างที่รู้ๆกันว่าคำสั่งใน **math.h** มันจะให้ผลเป็น **double** ซึ่ง double จะออกมาเป็นจำนวนจริงที่เป็น**ค่าประมาณ** แต่ทำไมกรณีนี้ใช้ได้ เรามาดูกัน!

เราสามารถมอง double คล้ายๆกับ **สัญกรณ์วิทยาศาสตร์** นั้นคือ a \* 10^b ไรงี้

แต่คอมพิวเตอร์มันไม่ได้อยู่**ในฐาน 10 ไง** เราเลยเปลี่ยนจาก a \* **10**^b เป็น a \* **2**^b ขออนุญาตเรียกมันว่า **สัญกอยณ์วิทยาศาสตร์** แทนนะ

![การเก็บDouble](https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/IEEE_754_Double_Floating_Point_Format.svg/618px-IEEE_754_Double_Floating_Point_Format.svg.png)

> อ้างอิงจาก en.wikipedia.org

* **sign** ก็คือ**เครื่องหมาย 0 = บวก 1 ก็คือ ลบ**
* **Exponent** คือเลขยกกำลัง (-1022 ถึง 1023)
* **Fraction** คือตัวเลขแมวๆ

ถ้าเป็น **สัญกรณ์วิทยาศาสตร์** จะ Fraction แบบ ฐาน 10 เช่น 1.059 = 1 + 5*10^-2 + 9^10^-3 ไรงี้(เก็บทีละตำแหน่ง)

แต่ถ้าเป็น **สัญกอยณ์วิทยาศาสตร์** จะ Fraction แบบ ฐาน 2 เช่น 1.059 ได้ประมาณ 1 + 2^-5 + 2^-6 + 2^-7 + 2^-8 +2^-12 + 2^-13+ 2^-15

> แล้วเราจะใช้ **สัญกอยณ์วิทยาศาสตร์** ในข้อนี้ได้ไหม 

ตอบว่าได้
เพราะเราสนใจแค่**ค่าประมาณเป็นจำนวนเต็มอยู่แล้ว**่ซึ่งโอกาสที่จะคลาดเคลื่อนมีน้อยมากๆ

> แล้วทำไมเราไม่ใช้ double แทนตัวแปร int เลยหละ

เพราะมันไม่เป๊ะไง เราพิสูจน์่ง่ายๆคือ เจ้า Double มันสามารถเป็น long long ได้ทุกจำนวนไหม

ซึ่งคำตอบคือ **เกือบครบทุกอัน**

ลองให้ Exponent เป็น 60 ก่อนละกัน(ผลลัพธ์ตอนนี้คือ 2^60) 

*ค่อยๆใส่ Fraction เข้าไป*

ลองใส่ 2^60 \* (1+2^-1) ก็จะได้ 2^60 + 2^59

ลองใส่ 2^60 \* (1+2^-1+2^-2) ก็จะได้ 2^60 + 2^59 + 2^58

ถ้าเราลองวนไล่ไปจนถึง 2^0 ก็จะต่อสู้กับ long long ได้

แต่ปัญหาคือเราไม่สามารถไล่จรถึง 2^0 เพรา**สัญกอยณ์วิทยาศาสตร์ มันเก็บ Fraction แค่ 52 บิต(บวกถึงแค่ 2^-51)**

และจาก "*บวกถึงแค่ 2^-51*" เราจึงสามารถสร้าง INT จาก Double **สูงสุดที่ 2^51 เท่านั้นน**
